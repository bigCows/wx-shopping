/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
declare function isArray(val?: any): boolean;
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
declare function isArrayBuffer(val?: any): boolean;
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
declare function isFormData(val?: any): boolean;
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
declare function isArrayBufferView(val?: any): boolean;
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
declare function isString(val?: any): boolean;
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
declare function isNumber(val?: any): boolean;
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
declare function isUndefined(val?: any): boolean;
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
declare function isObject(val?: any): boolean;
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
declare function isDate(val?: any): boolean;
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
declare function isFile(val?: any): boolean;
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
declare function isBlob(val?: any): boolean;
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
declare function isFunction(val?: any): boolean;
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
declare function isStream(val?: any): boolean;
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
declare function isURLSearchParams(val?: any): boolean;
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
declare function trim(str: string): string;
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * native script
 *  navigator.product -> 'NativeScript' or 'NS'
 */
declare function isStandardBrowserEnv(): boolean;
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
declare function forEach(obj: any, fn: Function): void;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @returns {Object} Result of all merge properties
 */
declare function merge(...obj: any[]): object;
/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @returns {Object} Result of all merge properties
 * @param obj
 */
declare function deepMerge(...obj: any[]): object;
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
declare function extend(a: any, b: object, thisArg?: any): any;
declare const _default: {
    isArray: typeof isArray;
    isArrayBuffer: typeof isArrayBuffer;
    isBuffer: any;
    isFormData: typeof isFormData;
    isArrayBufferView: typeof isArrayBufferView;
    isString: typeof isString;
    isNumber: typeof isNumber;
    isObject: typeof isObject;
    isUndefined: typeof isUndefined;
    isDate: typeof isDate;
    isFile: typeof isFile;
    isBlob: typeof isBlob;
    isFunction: typeof isFunction;
    isStream: typeof isStream;
    isURLSearchParams: typeof isURLSearchParams;
    isStandardBrowserEnv: typeof isStandardBrowserEnv;
    forEach: typeof forEach;
    merge: typeof merge;
    deepMerge: typeof deepMerge;
    extend: typeof extend;
    trim: typeof trim;
};
export default _default;
